* system_path, user_path, local_path, execution_path
  stxt import -system|user|local file.stxt
  sudo stxt import -system file.stxt

STXT CLI
stxt install file.stxt                  # == --local
stxt install --local file.stxt          # ./.stxt
stxt install --user  file.stxt          # ~/.stxt
stxt install --system file.stxt         # /etc/stxt   (o %PROGRAMDATA%\stxt)
stxt install --root /opt/stxt file.stxt # ruta arbitraria

Resoluci√≥n (cuando STXT corre)
Usa:

STXT_HOME
STXT_PATH
roots por defecto de StxtPaths

üëâ Completamente independiente del CLI.

5. Conclusi√≥n
--system, --user, --local deben tener rutas fijas
--root sirve para instalaciones personalizadas

No: no mezclar --system con STXT_PATH, ni hacer magia.


Componentes: xxx
Filter: name(lang, es): lessThan(nodename,3)
Template >>




* Parser con namespace
* Hacer todas las p√°ginas:
	Revisar especificaci√≥n lang
	Revisar especificiaci√≥n schema
	
Github
* Una plantilla de CI (GitHub Actions) para JS + Python + Java (github/mombiela/stxt)
* Un .editorconfig para tener estilos consistentes en todo el repo (github/mombiela/stxt)

===
Web
===

Mejorar estilo m√≥bil (css)

===
CLI
===

stxt nombre.stxt nombre2.pdf (transforma a pdf)
stxt nombre.stxt (todas las transforms que puede)
stxt . (todo lo que puede con *.stxt)
stxt in out

stxt: hace todo lo que puede
	-a -all: validate, transform2*, import-schema, import-transform (**** por defecto si no se dice nada!!!)
	-v -validate: validate
	-f -format: formato con treams, etc
	-c -clean: format + clean comments
	-4s: con 4 espacios
	-t: con tabulador (por defecto)
	-y: decir si a override
	-r: busca de forma recursiva en directorios
	-import-schema  (para @stxt.schema)
	-import-transform (para @stxt.transform)
	-export-schema 'com.example.*' 'org.apache.docs' file.stxt: exporta schema
	-export-transform 'com.example.*' 'org.apache.docs' file.stxt: exporta transform
	-export-all 'com.example.*' file.stxt: exporta schema+transform+...

	-2xml  -transform2xml  (@stxt.transform.xml)
	-2html -transform2html (@stxt.transform.html)
	-2yaml -transform2yaml
	-2toml -transform2toml
	-2pdf  -transform2pdf
	-2stxt -transform2stxt : es como migrar documentos de una versi√≥n a otra!! por ejemplo org.apache.docs -> org.apache.docs.v2
	-2css  -transform2css: es como sass, pero ordenado!! No se como hacerlo :-D
	
	-xml2 -transform-xml2: pasa de un xml a un stxt, hay que decir el namespace de llegada, ya que los origen no son tan cuquis como stxt
		-xml2 org.apache.docs
	-html2 -transform-html2: pasa de un xml a un stxt, hay que decir el namespace de llegada, ya que los origen no son tan cuquis como stxt
	-yaml2
	-toml2
	


Ideas
* Explicar que las webs (org.apache.*) pueden tener un documento donde explican todo!! Todos sus esquemas, transformaciones (incluye migraciones!!)
* Para pasar a HTML no hace falta transformar markdown, esto se hace por javascript, igual que LATEX, por ejemplo! S√≥lo hace falta transformaciones del tipo:
	Transform:
		Src: com.example.docs.Document
		Dst: div
		Pattern: opcional, 
	Transform:
		Src: com.example.docs.Document
		Dst: div
		Pattern: opcional, si no va a por todos los nombres de fichero (valorar si realmente es necesario!) 
	Transform:
		Src: com.example.docs.Document
		Custom Template >>
			<div class="${doc.namespace}.${doc.name}" data-type="${doc.type}">
				<pre>escapeHtml(${doc.text})</pre>
				<div class="md">
					markdown2Html(${doc.text})
				</div>
			</div>
* CMS: hace como con proyecto de semantictextbuilder. Aqu√≠ si que puede transformar directamente markdown
	* Una forma f√°cil se podr√≠a usar transformaci√≥n direct con stxt2html usando custom con placeholder @HEADER@, @INDEX@, etc.
		Despu√©s, ya por c√≥digo sencillo transformar los @@ por un contenido general o personalizado para la p√°gina en cuesti√≥n,
		al estilo de lo que hacemos con @STXT@
		
* Hacer ejemplos de Documentos corporativos para web, cms, etc.
* Mirar como hacer transformaci√≥n inversa, para poder migrar m√°s f√°cil
* Transformaciones pasar por un formato com√∫n para pasar luego a otro? valorar... quiz√° json, el propio stxt, etc.
* .github/workflow para autom√°tico (hay que hacer personal token que permita insertar workflows)



Filosof√≠a
Principio: Human-first
Consecuencias:
	* Visualmente coherente (con que editor o visualizador siga 4S=1T)
	* F√°cil de usar e implementar
	
stxt file.stxt file.html
	Pasar todo a divs con data-type, data-value para inline's, data-text dependiendo del tipo... Definir en transformaciones
	El css da formato
	
stxt es "Glue language!!"


El lenguaje
	* 1 minuto
	* tutorial
	* STXT REF
	* STXT Schema REF
	* Grammar
Casos de uso
	* Conversores stxt2
		* RFC
		* Config (tomcat, etc.)
		* ...
	* Documentos corporativos (fuente de verdad)
		* Wiki corp
		* Manuales
		* Contratos
		* ...
	* AI con docs corporativos!! Para RAG
	* CMS/gestores de contenido
	* Formatos editoriales: recetas, manuales, especificaciones,...
	* Wikipedia
	* Ficheros de configuraci√≥n: con descripci√≥n dentro!! mirar que Node: permita description!!!
Herramientas
	Parsers
	IDE's
	Online Editor
	

Oswald: Esta es una excelente alternativa. Es una fuente sans-serif redise√±ada y optimizada para pantallas digitales. Es estrecha, en√©rgica y tiene una presencia fuerte, pero mantiene un aire profesional y serio.
Bebas Neue: Una opci√≥n muy popular para titulares. Es una fuente sans-serif de caja alta, con l√≠neas limpias y un peso considerable que la hace muy contundente sin perder seriedad.
Anton: Similar en estilo condensado y audaz a Russo One, Anton ofrece un impacto visual significativo, ideal para un lenguaje que necesita ser notado y tomado en serio.
Archivo Narrow (en sus pesos Bold o Black): Ofrece una sensaci√≥n m√°s moderna y t√©cnica, manteniendo la robustez y legibilidad que necesitas para un sistema ling√º√≠stico. 

* Tipo por defecto: si tiene childs -> EMPTY, si no tiene childs INLINE_TEXT
* nombre(namespace)[cardinal]  (representa en tabla siempre min,max), parecido a NUMBER, etc.
	Example [*]
	Example [?]
* CASE-SENSITIVE para nombres!!
* INLINE TEXT
* MULTILINE TEXT 
* INLINE TEXT ['']
* MULTILINE TEXT[""] 
* Namespace con @normativo, @especial, @privado... sin @ es est√°ndar
* Falta validar nombre namespace
* Por defecto un nodo es empty!! Eso significa que necesita hijos
* Trim espacios intermedios de nombres hasta 1!! Tabs tambi√©n espacios!
* Un documento entero puede tener mezcla o s√≥lo hay problemas en la misma l√≠nea?
* LANG: Se permite esto LANG[yaml], LANG[markdown], LANG[html], LANG[javascript]
* CODE: Sin lang
* Se podr√≠a hacer tambi√©n: BOOLEAN, NUMBER, UUID, BASE64, HEX, BINARY 
* Documentar en 4.* que el nombre con estilo recomendado es 
	xxxx (@namespace): value
	xxxx: value o 
	xxxx: 
* Revisar documentaci√≥n! Cambian cosas!
* Comentarios: eliminar con normalizaci√≥n de espacios, son s√≥lo para el texto "en bruto"
* stxt validate, stxt trim, stxt normalize (igual que trim), stxt validate, stxt import-schema (stxt -is), stxt transform -pdf, stxt import-transform (stxt -it)
* carpeta local del usuario: normalmente /home/nombredeusuario/.stxt o C:\Users\nombredeusuario\.stxt
	./schema:
		dev.stxt.stxt (namespace dev.stxt)
		org.apache.docs.stxt (namespace org.apache.docs)
		com.google.docs.stxt
	./transform
		html
			org.aapache.docs
		yaml
		xml

STXT: Human-first
STXT: Built for humans. Reliable for machines.
Hacer intro de filosofia
Hacer p√°gina entera filosofia

Contactar Amaris!! Patrocinador/Impulsor
	CMS: partner o patrocinador o colaborador o mentor o soci tecnol√≤gic o impulsora o sponsor o protector
	APADRINAR!! Amaris es el padrino del lenguaje y lo hace crecer, cuida, etc.

=====================
Otras ideas a revisar
=====================

* Parser Java
	* stxt in -> json canonico, stxt compact, ns json cononico, error parseo
* Parser Javascript (+Node.js)
* Plugin VSCode
* Parser Python
* cli con node: stxt
	* Validate: stxt file.stxt
	* List namespaces: stxt --list-ns
	* Import namespace:	stxt --import-ns file.stxt|uri.stxt
	* JSON can√≥nico: stxt --json-canonical file.stxt
	* Clean (spaces): stxt --clean
	* ...
* cli con node, transformadores: stxt2
		* stxt2 file.stxt file.json
		* stxt2 file.stxt file.xml
		* stxt2 file.stxt file.xxx
	* Transformadores
* Otros cli's?
* WYSIWYG: editor en javascript para cms's
* Contactar con Costaisa (si quieren patrocinar proyecto)
* Documentaci√≥n:
	* Parseo en pseudoc√≥digo
	* Pruebas can√≥nicas
	* Casos de uso:
		* Documentos corporativos (fuente de verdad)
			* Wiki corp
			* Manuales
			* Contratos
			* ...
		* CMS/gestores de contenido
		* Wikipedia!! Contactar comunidad
		* AI con docs corporativos!! Para RAG
		* Ficheros de configuraci√≥n
		* Formatos editoriales: recetas, manuales, especificaciones,...
		* Ficheros stxt2
	* ...
* Maven con stxt
* Node con npm stxt
* Python con pip stxt
* Correo: contact@stxt.dev
* Dominios y aplicaciones
	* ns.stxt.dev          ‚Üí Repositorio de definiciones
	* stxt.dev             ‚Üí Landing + visi√≥n del proyecto
	* spec.stxt.dev        ‚Üí Especificaci√≥n oficial
	* docs.stxt.dev        ‚Üí Documentaci√≥n y tutoriales
	* play.stxt.dev        ‚Üí Playground (si lo haces)
	* api.stxt.dev         ‚Üí API REST del parser o servicios
	* cli.stxt.dev         ‚Üí Info del CLI e instaladores
	* plugins.stxt.dev     ‚Üí Extensiones de editores
	* ai.stxt.dev          ‚Üí Integraciones con IA
	* lab.stxt.dev         ‚Üí Experimentos	
	* org.stxt.dev         ‚Üí Sugerencias, lenguaje, etc.

* GTM o Patrocinadores

===============
ROADMAP INFO AI
===============


# üß© Orden final recomendado (roadmap oficial)

### **FASE 1 ‚Äî n√∫cleo del lenguaje**

1. Parser: 
	Javascript/Typescript
	Python
	Java	
2. Serializador JSON + pretty-printer
3. CLI m√≠nima (en node.js)

### **FASE 2 ‚Äî utilidad real**

4. Validador de schemas
5. Extensi√≥n VSCode
6. Playground

### **FASE 3 ‚Äî ecosistema**

7. Serializadores a otros formatos
8. Generador de documentaci√≥n
9. Linter sem√°ntico

# ‚úÖ **1. Parser oficial (core STXT-SPEC) ‚Äî obligatorio**

El parser es la base para absolutamente todo lo dem√°s.

Debe implementar **100% del STXT-SPEC**:

* indentaci√≥n estricta
* mezcla espacios/tabs prohibida
* nodos `:`
* nodos `>>`
* comentarios fuera de bloques
* normalizaci√≥n (nombres, inline, bloques)
* errores formales

**Lenguajes prioritarios:**

1. **JavaScript / TypeScript**

   * Porque sirve para web, para Node, y para integraciones.
2. **Python**

   * Para automatizaciones, pipelines, IA, APIs.
3. **Java**

   * Importante en enterprise.

Despu√©s: C#, Go, Rust.

**En cada versi√≥n:**

* parsear ‚Üí entregar √°rbol can√≥nico ‚Üí sin validaci√≥n sem√°ntica.

---

# ‚úÖ **2. Serializador (canonical JSON / stxt pretty-print)** ‚Äî imprescindible

Un parser sin serializador no permite test unitarios reproducibles.

Necesitas:

### 2.1. JSON can√≥nico

Basado en lo que ya definiste:

```json
{
  "documents": [
      { "name": "Documento", "namespace": "@x", "children": [...] }
  ]
}
```

* siempre orden estable
* sin espacios sobrantes
* sin claves opcionales vac√≠as

Sirve para:

* comparar dos parsers
* test cross-language
* herramientas de CI

### 2.2. Pretty-printer stxt (opcional pero muy √∫til)

Transforma el √°rbol parseado en stxt formateado uniformemente.

Sirve para:

* estilizar documentos
* editor / extension VSCode
* auto-format

---

# ‚úÖ **3. Validador de schemas (STXT-SCHEMA-SPEC)** ‚Äî muy prioritario

Una vez el parser existe, el validador es el segundo gran pilar.

Debe implementar:

* carga de schemas
* asociaci√≥n por namespace
* tipos (TEXT, NUMBER, BASE64, CODE, etc.)
* cardinalidades
* modo **strict** y modo **non-strict**
* regla 7.1 obligatoria
* errores precisos con l√≠nea y tipo

Este componente es el que transforma stxt en un lenguaje *√∫til para datos reales* (similar a JSON Schema, pero human-first).

---

# ‚úÖ **4. CLI oficial (`stxt`)** ‚Äî alt√≠simo valor pr√°ctico

Una herramienta de l√≠nea de comandos que haga:

* `stxt parse file.stxt` ‚Üí JSON can√≥nico
* `stxt validate file.stxt` ‚Üí aplica schema
* `stxt format file.stxt` ‚Üí pretty-print
* `stxt check file.stxt` ‚Üí lint b√°sico + errores de indentaci√≥n

Esto tambi√©n alimenta:

* CI/CD
* Makefiles
* integraci√≥n con editores
* scripts autom√°ticos

Idealmente escrito en Node.js (cross-platform inmediato) o Rust (portabilidad + velocidad + binarios peque√±os).

---

# ‚úÖ **5. Extensi√≥n VSCode** ‚Äî imprescindible a nivel de adopci√≥n

Incluye:

### M√≠nimo viable:

* coloreado (syntax highlighting)
* plegado de bloques (folding de jerarqu√≠a)
* reconocimiento b√°sico de `:` y `>>`

### Fase 2:

* autocompletado de nombres seg√∫n schema
* validaci√≥n en tiempo real
* tooltip con tipo / cardinalidad
* auto-format

Esta herramienta multiplica la adopci√≥n del lenguaje.

---

# ‚úÖ **6. Playground web**

Una web interactiva:

* editor con stxt a la izquierda
* JSON can√≥nico a la derecha
* validaci√≥n con schema opcional
* indicadores de error en tiempo real

Ideal ejemplo: ‚ÄúJSON Editor Online‚Äù pero para stxt.

Esto es fant√°stico para documentaci√≥n y demos.

---

# ‚úÖ **7. Libraries para serializar stxt a otros formatos (opcional pero √∫til)**

* Serializador stxt ‚Üí **YAML**
* Serializador stxt ‚Üí **JSON**
* Serializador stxt ‚Üí **Markdown**
* Serializador stxt ‚Üí **HTML**

La m√°s esencial es stxt ‚Üí JSON (ya cubierto), pero un par de extras pueden dar mucho valor en algunos contextos.

---

# ‚úÖ **8. Generador de documentaci√≥n a partir de schemas**

Similar a:

* JSON Schema ‚Üí documentaci√≥n HTML
* OpenAPI ‚Üí swagger UI

Con un schema stxt, generar:

* tabla de nodos
* cardinalidades
* tipos
* descripciones
* ejemplos de uso

Muy √∫til para publicar APIs sem√°nticas basadas en stxt.

---

# ‚úÖ **9. Linter sem√°ntico (encima del validador)**

Reglas de estilo:

* evitar nombres ambiguos
* evitar nodos vac√≠os sin necesidad
* recomendaci√≥n sobre orden de nodos
* gu√≠as de estilo corporativo

Esto ya no es esencial para lanzamiento, pero s√≠ √∫til en equipos grandes.

---




========================================================================================================================================
@stxt.slots: Deprecated o en revisi√≥n. Despu√©s de hacer pruebas, parace demasiado verboso para hacer xml o yaml. Mirar proyecto @stxt.t2
========================================================================================================================================


* STXT Slots, pasa de STXT a otros
	* Import xml: hace un STXT est√°ndard, del que se dir√° el schema de llegada. Esto para migraci√≥n. Despu√©s, se pasa STXT Slots para pasarlo al de destino.
	  Ejemplo: 
	  	<demo id="3">
	  		<otro>Valor</valor>
	  	</demo>
	  	
	  STXT:
	  	demo:
	  		content: ""
	  		attr:
	  			id: 3
	  		childs:
	  			otro: 
	  				content: Valor
	* Igual para YAML



Template:

Mini lenguaje de templates:

Separador ini: {{ (permitimos cambiar a otra cosa, como  @@ o << ?
Separador end: }} (permitimos cambiar a otra coas como   @@ o >> ? 

Tienen la forma: {{op1:op2:op3:...opn}}

op1: name_op[param opcional]

Las operaciones retornan o bien texto o bien un nodo o un listado de nodos y se van concatenando las operaciones.
Las operaciones DEBEN terminar en un texto.

----------------------------------------
Operaciones b√°sicas que DEBE implementar
----------------------------------------

text: Retorna el texto de un nodo. Aplicable a nodo. Si se aplica a un string retorna el mismo string
children: Retorna los hijos
name: Retorna el nombre (aplicable a un nodo)
name[a name]: Filtra por 'a name' de un listado de nodos
type: Retorna el tipo de un nodo. Aplicable a nodo.
type[a type]: Filtra por 'a type' de un listado de nodos
subtype: Retorna el subtipo de un nodo. Aplicable a nodo
subtype[a subtype]: Filtra por el subtipo de un listado de nodos
render: Renderiza el listado y concatena con ''
render[',']: Renderiza el listado y concatena con
to_upper_case: Aplica a texto
to_lower_case: Aplica a texto
escape_html: Escapa como html
escape_xml: Escapa como xml
escape_js: Escapa como javascript
escape_attrib: Escapa como atrib de xml (quiz√° otro nombre?)

to_canonic_html???

-------------------------------------------
Operaciones comunes que 'PUEDE' implementar
-------------------------------------------

markdown: Aplica a un texto (NO a un nodo!) y retorna un markdown. Si no est√° disponible retorna el mismo texto

Ejemplos:

{{text}}	Hola Mundo!
{{type}}    NUMBER, LANG
{{type:subtype}}  markdown
{{children}}  Iteramos childs
{{children:name[apellido]:render}}  Iteramos childs s√≥lo con nombre 'apellido'
{{child:a name}}   S√≥lo un child (si s√≥lo hay uno, si hay m√°s error)
{{text:markdown}}       Text a markdown
{{text:escape_html}} Text escapado





S√≥lo se transforman autom√°ticos documentos con namespace. Los que no tienen usan transformaci√≥n por defecto pero a demanda. 
Si tienen namespace DEBEN tener definida una transformaci√≥n, ni que sea la de defecto, sin√≥ error de transformaci√≥n.

STXT2HTML
	- Divs con namespace:
		<div class="${doc.namespace}.${doc.name}" data-type="${doc.type}">
			${doc.text}
		</div>
	- Divs sin namespace:
		<div class="${doc.name}">
			${doc.text}
		</div>

STX2HTML (@stxt.transforms):
    Namespace: com.example.docs

    Node: Document
        Template >>
            <h1>{{text}}</h1>
            {{childs}}
